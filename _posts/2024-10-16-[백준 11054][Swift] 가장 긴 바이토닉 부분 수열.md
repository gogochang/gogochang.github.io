> ## [백준 1932번: 가장 긴 바이토닉 부분 수열](https://www.acmicpc.net/problem/11054)
> 
> ### **문제**
> ---
> 수열 S가 주어졌을 때, 그 수열의 부분 수열 중에서 **바이토닉 부분 수열**이면서 가장 긴 것을 구하는 프로그램을 작성하시오.
> 
> 바이토닉 수열이란, 수열이 다음과 같은 조건을 만족하는 경우이다.
> 
> 1. S1 < S2 < ... < Sk > Sk+1 > ... > Sn (1 ≤ k ≤ n, k는 수열의 임의의 위치)
> 
> 즉, 처음에는 오름차순으로 증가하고, 그 후에는 내림차순으로 감소하는 수열을 말한다.
> 
> ### **입력**
> ---
> 첫째 줄에 수열 A의 크기 N이 주어진다. (1 ≤ N ≤ 1,000)
> 
> 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)
> 
> ### **출력**
> ---
> 첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 부분 수열의 길이를 출력한다.

## **접근방법**
---
1. **DP(Dynamic Programming, 동적 계획법)**\
수열을 저장하면서 현재 값을 구하기 위해 이전에 이미 계산된 데이터를 재사용하기 때문에 DP가 사용된다.

2. **바이토닉 수열**\
이 문제를 풀기 앞서, 바이토닉 수열이 무엇인지 이해하는것이 중요하다.
바이토닉 수열이란 한 지점을 기준으로 오름차순으로 증가하다가 다시 내림차순으로 감소하는 수열이다.

3. **증가수열(LIS)**\
증가하는 수열은 한 지점의 기준으로 왼쪽에 존재해야한다.

4. **감소수열(LDS)** \
감소하는 수열은 한 지점의 기준으로 오른쪽에 존재해야한다.

5. **증가수열(LIS)과 감소수열(LDS)의 분리**\
바이토닉 수열의 증가 -> 감소 형태인 문제를 코드로 구현하기 위해 한 지점을 기준으로 왼쪽에서 증가하는 증가수열(LIS)과 오른쪽에서 감소하는 감소수열(LDS) 두 값을 구해 특정 지점의 최장 바이토닉 부분 수열을 구한다.

## **코드**
---
```swift
let n = Int(readLine()!)! // 수열의 길이
let arr = readLine()!.split(separator: " ").map { Int($0)! } // 수열 A
var lis = Array(repeating: 1, count: n) // 증가하는 부분 수열(LIS)
var lds = Array(repeating: 1, count: n) // 감소하는 부분 수열(LDS)

// 1. LIS 계산 (왼쪽에서 오른쪽으로)
for i in 0..<n {
    for j in 0..<i {
        if arr[j] < arr[i] {
            lis[i] = max(lis[i], lis[j]+1)
        }
    }
}

// 2. LDS 계산 (오른쪽에서 왼쪽으로)
for i in (0..<n).reversed() {
    for j in (i+1)..<n {
        if arr[i] > arr[j] {
            lds[i] = max(lds[i], lds[j]+1)
        }
    }
}

// 3. LIS와 LDS를 더한 값에서 종복된 기준점 1개를 제외한 값 계산
var maxLength = 0
for i in 0..<n {
    maxLength = max(maxLength, lis[i] + lds[i] - 1)
}

print(maxLength)

```

## **코드설명**
---
이 코드는 주어진 수열에서 가장 긴 바이토닉 부분 수열을 찾는 문제를 해결한다. 이를 위해 **증가하는 부분 수열(LIS)**과 **감소하는 부분 수열(LDS)**을 각각 구한 후, 두 값을 결합해 가장 긴 바이토닉 부분 수열의 길이를 계산한다.
1. **LIS 계산 (왼쪽에서 오른쪽으로)**
    * `lis`배열은 각 원소에서 끝나는 최장 증가 부분 수열의 길이를 저장한다.
    * 현재 값이 앞의 값보다 크다면, 이전 값에 현재 값을 추가하여 수열을 확장할 수 있다.
    * 관련 알고리즘 : [LIS 알고리즘](http://naver.com)
2. **LDS 계산 (오른쪽에서 왼쪽으로)**
    * `lds`배열은 각 원소에서 시작하는 최장 감소 부분 수열의 길이를 저장한다.
    * 현재 값이 뒤의 값보다 크다면, 이후 값에 현재 값을 추가하여 수열을 확장할 수 있다.
    * `reversed()`를 통해 수열을 끝(오른쪽)부터 저장할 수 있다. 
    * 관련 알고리즘 : [LDS 알고리즘](http://naver.com)
3. **LIS와 LDS를 더한 값에서 종복된 기준점 1개를 제외한 값 계산**
    * 한 지점에서 LIS와 LDS를 합치면 해당 지점의 바이토닉 수열의 길이를 구할 수 있다.\
     `lis`와 `lds`의 구하고자하는 지점에는 서로 길이를 하나씩 가지고 있기 때문에 중복된 기준점을 제거하기 위해 `1`을 빼준다.
    * 모든 지점에서의 바이토닉 수열의 길이 중 가장 큰 값을 구한다.

## **마무리**
---
처음에는 바이토닉 수열이라는 개념이 좀 낯설었다.\
증가 수열과 감소 수열이 하나의 흐름으로 이어진다고만 생각하고 접근했었는데,\
문제를 분석하면서 **증가수열(LIS)**과 **감소수열(LDS)**을 각각 따로 계산하는 방식이 이 문제의 핵심이었다.\
큰 문제를 더 작은 단위로 나누어 분석하고 해결하는 방법 기억하자.